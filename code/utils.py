'''
Created on 06 nov 2017

@author: matteo
'''
import os
import random
import datetime
import time


'''
method that returns a dictionary of malware apps. The dictionary has as key an integer as value the sha256 encripted name
of the malware app. On drebin csv, there are 5560 known malware. 
'''
def getKnownMalwareDict(malware_list_path):
    malware_file = open(malware_list_path,'r')
    malware_list = malware_file.readlines()
    """dictionary integer:sha256_malware"""
    known_malware_dict = {}
    i=0
    """header_skip is used to remove the header table in the csv file, without inserting it in the dict"""
    header_skip = 1
    for line in malware_list:
        if header_skip:
            header_skip = 0
            """skip the header"""
            continue
        line = line.replace(",", " ", 1).split()
        known_malware_dict[i] = line[0]
        i+=1    
    return known_malware_dict

'''
method that returns a list of sha_256 app names shuffled randomly
'''
def getShuffledListApps(app_directory_path):
    apps_names = []
    for app_sha256_name in os.listdir(app_directory_path):
        apps_names.append(app_sha256_name)
    random.shuffle(apps_names)
    return apps_names

'''
method that returns a list of features that are considered during the learning/classification (deterministically). 
The list of possible features are known (10).
'''
def getTargetFeatures():
    all_features = ["api_call", 
                    "permission", 
                    "url", 
                    "provider", 
                    "feature", 
                    "call", 
                    "activity", 
                    "intent", 
                    "service_receiver",
                    "real_permission"]
        
    """ this can be changed on new instances of NaiveBayes """
    valid_feature_set = [all_features[0], all_features[1], all_features[3], all_features[5], all_features[6], all_features[9]]
    return valid_feature_set


'''
method that apply the Naive Bayes to the dataset in input, using k-cross validation. 
It returns the accuracy, precision, recall, f-measure and false positive rate.
'''
def applyNaiveBayes(app_directory_path,
                    known_malware_dict,
                    k_fold):
    """ Among all the features available (10), 
	only a subset is taken to avoid huge computational time """
    searched_features = getTargetFeatures()
    print "considered features: " + str(searched_features)
    
    """ get a shuffled list of all the sha_256 app names s.t. 
	in every instance of NaiveBayes, the pool is randomized """
    shuffled_app_names = getShuffledListApps(app_directory_path)
    tot_apps = len(shuffled_app_names)
    print "number of applications considered: " + str(tot_apps)
    
    print "number of k-fold: " + str(k_fold)
    step = tot_apps//k_fold
    
    """ list containing tuples of 4 elements corresponding to
	TP, TN, FP and FN for each step k"""
    evaluation_metrics_data = []
    
    """ k-cross validation """
    iter=1
    for i in range(0,step*k_fold,step):
        truePos = trueNeg = falsePos = falseNeg = 0    
        """ evaluation set for the step k containing the sha_256 digest of the apps """
        validSet_app_names = shuffled_app_names[i:i+step]
        """ training set for the step k containing the sha_256 digest of the apps """
        trainSet_app_names = shuffled_app_names[0:i] + shuffled_app_names[i+step:tot_apps]
        """ start training on the trainingSet """
        (malware_dict,occMalwFeatures) = doTraining(app_directory_path,
                                                    trainSet_app_names, 
                                                    known_malware_dict, 
                                                    searched_features)
        """ start classification on the validSet"""
        for app_sha256_name in validSet_app_names:
            isMalware = 0 
            if app_sha256_name in known_malware_dict.viewvalues():
                isMalware = 1 
            path_app_sha256_name = app_directory_path + "/" + app_sha256_name 
            valid_current_app = open(path_app_sha256_name,'r')
            valid_current_app = valid_current_app.readlines()
            """ isMalware is the correct class for the valid current_app. 
			If the classification missclassify the app, a FP or FN occurs """
            classification = classify(valid_current_app,
							   searched_features,
							   malware_dict,
							   occMalwFeatures)
			
			if  classification!= isMalware:
                if isMalware:
                    falseNeg+=1
                else:
                    falsePos+=1
             else:
                if isMalware:
                    truePos+=1
                else:
                    trueNeg+=1
     
        """ some useful infos for the report """    
        print "iteration " + str(iter)
        print "--> # malware in the training set: " + str(occMalwFeatures[0]) + 
			  "/" + str(len(trainSet_app_names))
        print "--> # not malware in the training set: " + str(occMalwFeatures[1]) +
			  "/" + str(len(trainSet_app_names))
        print "--> # True positive: " + str(truePos)
        print "--> # True negative: " + str(trueNeg)
        print "--> # False positive: " + str(falsePos)
        print "--> # False negative: " + str(falseNeg)
        iter+=1
        
        evaluation_metrics_data.append((truePos,trueNeg,falsePos,falseNeg))
    
    return getEvalutationMetrics(evaluation_metrics_data, k_fold)


'''
method that returns some parameters (as a list) and dictionary with the following structure:
- key: valid feature name (valid means that the feature is one of those that we want consider during the training/classification
- value: a second dictionary containing as key the info associated to that specific feature and as value a couple of integer,
representing the occurrence of that feature::info respectively into malware app and not malware app
The returned parameters are:
- the number of malware apps found in the training set in input
- the number of not malware apps found in the training set in input
- the number of feature::info (the info associated to a specific feature) found into all malware apps of the training set (counting duplicates)
- the number of feature::info found into all not malware apps of the training set (counting duplicates)
- the number of unique feature::info found into all apps of the training set, either malware or not
'''
def doTraining(app_directory_path,shuffled_app_names,known_malware_dict,searched_features):
    malware_dict = {}
    numFeatureInfoMalw = 0
    numFeatureInfoNotMalw = 0
    numMalwareApps = 0
    numNotMalwareApps = 0
    numUniqueFeatureInfo = 0
    
    """ for each app manifest in shuffled list of app names """
    for app_sha256_name in shuffled_app_names:
        isMalware = 0
        path_app_sha256_name = app_directory_path + "/" + app_sha256_name 
        current_app = open(path_app_sha256_name,'r')
        current_app = current_app.readlines()
        """ if the current app is a known malware, then the flag isMalware is set to true"""
        if app_sha256_name in known_malware_dict.viewvalues():
            isMalware=1
            numMalwareApps+=1
        else:
            numNotMalwareApps+=1
        """for each line in the current app """
        for feature_line in current_app:
            feature_line = feature_line.replace("::", " ", 1).split()
            '''condition used to skip an iteration of the loop if 1 of 2 conditions are met:
                - some \n in the app manifest appears (empty lines)
                - some features not requested appear during the scanning
            '''
            if len(feature_line)==0 or not(feature_line[0] in searched_features):
                continue
            """ Case 1: the feature encountered has already been stored as 
			a key in the dictionary"""
            if feature_line[0] in malware_dict:
                feature_info_malware_dict = malware_dict[feature_line[0]]
                """ Case 1.1: the current feature::info is not already been stored 
				in the nested dictionary """
                if not feature_line[1] in feature_info_malware_dict:
                    numUniqueFeatureInfo+=1
                    if isMalware:
                        numFeatureInfoMalw+=1
                        feature_info_malware_dict[feature_line[1]] = (1,0)
                    else:
                        numFeatureInfoNotMalw+=1
                        feature_info_malware_dict[feature_line[1]] = (0,1)
                else:
                    """ Case 1.2: the current feature::info is already present in 
					the dictionary, only update required"""
                    """ if the current app is considered as malware from the csv,
					then the corrispondent occurrence is incremented """
                    if isMalware:
                        numFeatureInfoMalw+=1
                        (occMalw,occNotMalw) = feature_info_malware_dict[feature_line[1]]
                        feature_info_malware_dict[feature_line[1]] = (occMalw+1,occNotMalw)
                    else:
                        numFeatureInfoNotMalw+=1
                        (occMalw,occNotMalw) = feature_info_malware_dict[feature_line[1]]
                        feature_info_malware_dict[feature_line[1]] = (occMalw,occNotMalw+1)
                        
            else:
                """ Case 2: the feature encountered is not in the dictionary, it's new """
                new_feature_info_malware_dict = {}
                numUniqueFeatureInfo+=1
                if isMalware:
                    numFeatureInfoMalw+=1
                    new_feature_info_malware_dict[feature_line[1]] = (1,0)
                else:
                    numFeatureInfoNotMalw+=1
                    new_feature_info_malware_dict[feature_line[1]] = (0,1)
                malware_dict[feature_line[0]] =  new_feature_info_malware_dict
            
    occMalwFeature = [numMalwareApps,
					numNotMalwareApps,
					numFeatureInfoMalw,
					numFeatureInfoNotMalw,
					numUniqueFeatureInfo]
    return (malware_dict,occMalwFeature)

'''
method that return 1 if the current app is classified as a Malware, 0 otherwise
'''
def classify(current_app,
             searched_features,
             malware_dict,
             occMalwFeatures):
    isMalware = 0
    """ following parameters are explicity renamed to semplify 
	their recognition in the code """
    priorProbMalw = occMalwFeatures[0]/float(occMalwFeatures[0]+occMalwFeatures[1])
    priorProbNotMalw = occMalwFeatures[1]/float(occMalwFeatures[0]+occMalwFeatures[1])
    totUniqueInfoFeatures = occMalwFeatures[4]
    numFeatureInfoMalware = occMalwFeatures[2]
    numFeatureInfoNotMalware = occMalwFeatures[3]
    
    
    """ i=1,2 because there are only two classes available """
    for i in range(2):
        if i==0:
            probMalw = priorProbMalw
        else:
            probNotMalw = priorProbNotMalw
        for feature_line in current_app:
            feature_line = feature_line.replace("::", " ", 1).split()
            '''condition used to skip an iteration of the loop if 1 of 2 conditions are met:
                - some \n in the app manifest appears (empty lines)
                - some features not requested appeared during the scanning
            '''
            if len(feature_line)==0 or not(feature_line[0] in searched_features):
                continue
            """ if exsist the couple feature::info in the dictionary """
            if feature_line[1] in malware_dict[feature_line[0]]:
                feature_dict = malware_dict[feature_line[0]]
                (occMalw,occNotMalw) = feature_dict[feature_line[1]]    
                if i==0:
				tot=numFeatureInfoMalware+totUniqueInfoFeatures
                    prob_featureXclass = ((occMalw+1)/float(tot))
                    probMalw*= prob_featureXclass
                else:
				tot=numFeatureInfoNotMalware+totUniqueInfoFeatures
                    prob_featureXclass = ((occNotMalw+1)/float(tot))
                    probNotMalw*= prob_featureXclass
    if probMalw > probNotMalw:
        isMalware=1
    return isMalware


'''
method that returns all evaluation metrics according to the chosen k-fold (normalization)
'''
def getEvalutationMetrics(evaluation_metrics_data,k_fold):
    normTP = normTN = normFP = normFN = 0
    for (tp,tn,fp,fn) in evaluation_metrics_data:
        normTP+=tp
        normTN+=tn
        normFP+=fp
        normFN+=fn
    normTP = normTP/float(k_fold)
    normTN = normTN/float(k_fold)
    normFP = normFP/float(k_fold)
    normFN = normFN/float(k_fold)
    precision = getPrecision(normTP,normFP)
    recall = getRecall(normTP, normFN)
    falsePosRate = getFalsePosRate(normTN, normFP)
    accuracy = getAccuracy(normTP,normTN,normFP,normFN)
    fMeasure = getFMeasure(precision, recall)
    return (precision, recall, falsePosRate, accuracy, fMeasure)
    
'''
method that returns the precision of the executed instance of Naive Bayes
'''
def getPrecision(tp,fp):
    precision = tp/float(tp+fp)
    return precision
    
'''
method that returns the recall of the executed instance of NaiveBayes
'''
def getRecall(tp,fn):
    recall = tp/float(tp+fn)
    return recall

'''
method that returns the false positive rate of the executed instance of NaiveBayes
'''
def getFalsePosRate(tn,fp):
    falsePosRate = fp/float(fp+tn)
    return falsePosRate

'''
method that returns the accuracy of the executed instance of NaiveBayes
'''
def getAccuracy(tp,tn,fp,fn):
    accuracy = (tp+tn)/float(tp+fn+tn+fp)
    return accuracy
'''
method that returns the F-measure of the executed instance of NaiveBayes. Best value 1, worst 0.
'''
def getFMeasure(precision,recall):
    fMeasure = 2*(precision*recall)/float(precision+recall)
    return fMeasure